// main.js

// Инициализация приложения
// window.currentCategory = 'все'; // Устанавливается в loadCategoriesAndSetupFilters

document.addEventListener('DOMContentLoaded', async () => {
  console.log(">>> [DEBUG] DOM загружен, инициализация приложения");

  // Установка обработчиков событий (для поиска, корзины, модалок и т.д.)
  // Это настраивает обработчики, которые не зависят от динамически созданных элементов
  setupEventListeners();

  // Загрузка категорий, создание кнопок и установка их обработчиков
  // Также запускает первый рендер товаров
  await loadCategoriesAndSetupFilters();

  // updateCartCount(); // Можно вызвать здесь, если нужно обновить счетчик сразу
  // Но loadCategoriesAndSetupFilters -> renderProducts уже делает рендер,
  // а updateCartCount вызывается из addToCart/clearCart
});

// --- Остальной ваш код из main.js, если он есть --- // ui.js

// DOM-элементы
const productsContainer = document.getElementById('products');
const searchInput = document.getElementById('search-input');
let categoryButtons = []; // Будет обновляться после создания кнопок
const cartBtn = document.getElementById('cart-btn');
const cartModal = document.getElementById('cart-modal');
const productModal = document.getElementById('product-modal');
const cartItems = document.getElementById('cart-items');
const phoneInput = document.getElementById('phone-input');
const commentInput = document.getElementById('comment-input');
const sendOrderBtn = document.getElementById('send-order');
const successMessage = document.getElementById('success-message');
const yearSpan = document.getElementById('year');
let renderProductsTimeout;

// --- Вспомогательные функции ---

// Функция для получения корзины из localStorage
function getCart() {
    const cart = localStorage.getItem('cart');
    return cart ? JSON.parse(cart) : [];
}

// Функция для добавления товара в корзину
function addToCart(product) {
    if (!product || !product.id) {
        console.error('Невозможно добавить товар: неверные данные', product);
        return;
    }
    const cart = getCart();
    const existingItemIndex = cart.findIndex(item => item.product.id === product.id);

    if (existingItemIndex > -1) {
        cart[existingItemIndex].qty += 1;
    } else {
        cart.push({ product: product, qty: 1 });
    }

    localStorage.setItem('cart', JSON.stringify(cart));
    updateCartCount();
    console.log(`Товар ${product.title} добавлен в корзину`);
}

// Функция для обновления количества товара в корзине
function updateQuantity(productId, change) {
    const cart = getCart();
    const itemIndex = cart.findIndex(item => item.product.id === productId);

    if (itemIndex !== -1) {
        cart[itemIndex].qty += change;
        if (cart[itemIndex].qty <= 0) {
            cart.splice(itemIndex, 1); // Удаляем товар, если количество <= 0
        }
        localStorage.setItem('cart', JSON.stringify(cart));
        updateCartCount();
    }
}

// Функция для очистки корзины
function clearCart() {
    localStorage.removeItem('cart');
    updateCartCount();
}

// Функция для обновления счетчика товаров в корзине (пример)
function updateCartCount() {
    const cartCountElement = document.getElementById('cart-count'); // Предполагаемый ID
    if (cartCountElement) {
        const count = getCart().reduce((total, item) => total + item.qty, 0);
        cartCountElement.textContent = count > 0 ? count : '';
        // cartCountElement.style.display = count > 0 ? 'inline' : 'none';
    }
}

// Функция для форматирования цены
function formatPrice(priceInCents) {
    // Предполагаем, что цена хранится в копейках/центах
    const priceInRubles = priceInCents / 100;
    return new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'RUB' }).format(priceInRubles);
}

// --- Установка года ---
if (yearSpan) {
    yearSpan.textContent = new Date().getFullYear();
}

// --- Функции для работы с категориями и фильтрацией ---

// 1. Загрузка категорий с сервера и настройка фильтров
async function loadCategoriesAndSetupFilters() {
    const tagsContainer = document.querySelector('.tags');
    if (!tagsContainer) {
        console.error('Контейнер для тегов (.tags) не найден в DOM');
        // Даже если контейнер не найден, устанавливаем дефолтную категорию
        window.currentCategory = 'все';
        renderProducts(); // Инициируем рендер с дефолтной категорией
        return;
    }

    try {
        const res = await fetch('/api/categories');
        if (!res.ok) {
            console.warn('Не удалось загрузить категории с сервера, используем локальные.');
            throw new Error('Categories fetch failed');
        }
        let categories = await res.json();
        console.log('Категории загружены с сервера:', categories);

        // --- Подготовка списка категорий ---
        // 1. Создаем объект для категории "все"
        const allCategory = { slug: 'все', name: 'все' };
        // 2. Фильтруем, чтобы "все" не было в списке из API (если оно там есть)
        categories = categories.filter(cat => cat.slug !== 'все');
        // 3. Ставим "все" в начало
        categories.unshift(allCategory);

        // --- Рендер кнопок категорий ---
        renderCategoryButtons(categories, tagsContainer);

        // --- Установка обработчиков событий для кнопок категорий ---
        setupCategoryEventListeners();

        // --- Установка начальной категории ---
        // window.currentCategory уже установлена в main.js как 'все'
        // Но на всякий случай переустановим
        window.currentCategory = 'все';
        console.log("Начальная категория установлена:", window.currentCategory);

        // --- Первичный рендер товаров ---
        renderProducts();

    } catch (err) {
        console.error('Ошибка при загрузке или обработке категорий:', err);
        // --- Fallback на локальные категории ---
        const defaultCategories = [
            { slug: 'все', name: 'все' },
            { slug: 'headset', name: 'шлемы' },
            { slug: 'accessory', name: 'крепления' },
            { slug: 'battery', name: 'аккумуляторы' },
            { slug: 'charger', name: 'док-станции' }
        ];
        renderCategoryButtons(defaultCategories, tagsContainer);
        setupCategoryEventListeners();

        window.currentCategory = 'все';
        renderProducts();
    }
}

// 2. Рендер кнопок категорий в DOM
function renderCategoryButtons(categories, container) {
    container.innerHTML = ''; // Очищаем контейнер
    categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = 'tag-btn';
        // Активируем кнопку "все" по умолчанию или текущую выбранную категорию
        if (cat.slug === 'все' || cat.slug === window.currentCategory) {
            btn.classList.add('active');
        }
        btn.dataset.category = cat.slug; // Используем slug для data-атрибута
        btn.textContent = cat.name;
        container.appendChild(btn);
    });
    console.log("Кнопки категорий созданы и добавлены в DOM");
}

// 3. Установка обработчиков событий для кнопок категорий
function setupCategoryEventListeners() {
    // Получаем свежий список кнопок после их создания
    const buttons = document.querySelectorAll('.tag-btn');
    console.log(`Найдено ${buttons.length} кнопок категорий для установки обработчиков`);

    buttons.forEach(btn => {
        // Простое решение: удалить старый обработчик (если есть) и добавить новый
        // Это помогает избежать дублирования событий
        const newBtn = btn.cloneNode(true); // Клонируем кнопку без обработчиков
        btn.parentNode.replaceChild(newBtn, btn); // Заменяем старую на новую

        newBtn.addEventListener('click', () => {
            // Убираем класс 'active' у всех кнопок
            document.querySelectorAll('.tag-btn').forEach(b => b.classList.remove('active'));
            // Добавляем класс 'active' только нажатой кнопке
            newBtn.classList.add('active');

            // Получаем выбранную категорию из data-атрибута
            const selectedCategory = newBtn.dataset.category;
            if (selectedCategory !== undefined) {
                window.currentCategory = selectedCategory;
                console.log("Выбрана категория:", window.currentCategory);
                // Перерисовываем товары с учетом новой категории
                renderProducts();
            } else {
                console.error("У кнопки категории отсутствует data-category атрибут:", newBtn);
            }
        });
    });
    console.log("Обработчики событий для кнопок категорий установлены");
}

// --- Функция рендеринга товаров с фильтрацией ---
async function renderProducts() {
    // Отменяем предыдущий таймаут рендера, если он есть (debounce)
    if (renderProductsTimeout) {
        clearTimeout(renderProductsTimeout);
    }

    // Устанавливаем новый таймаут
    renderProductsTimeout = setTimeout(async () => {
        try {
            // 1. Получаем товары с сервера
            const res = await fetch('/api/products');
            if (!res.ok) {
                throw new Error(`HTTP error! status: ${res.status}`);
            }
            const PRODUCTS = await res.json();
            console.log("Товары загружены с сервера:", PRODUCTS.length, "шт.");

            // 2. Получаем значения фильтров
            const query = (searchInput?.value || '').toLowerCase().trim();
            const currentCategory = window.currentCategory; // Получаем из глобальной переменной

            console.log("Применяем фильтры: поиск =", query, ", категория =", currentCategory);

            // 3. Фильтруем товары
            const filteredProducts = PRODUCTS.filter(p => {
                const isAvailable = p.available !== false; // Считаем доступным, если available === true или undefined

                // --- Фильтр по категории ---
                const categoryMatch = currentCategory === 'все' || p.category === currentCategory;
                // console.log(`Товар ${p.id}: категория '${p.category}' совпадает с '${currentCategory}'?`, categoryMatch);

                // --- Фильтр по поиску ---
                const searchMatch =
                    query === '' ||
                    (p.title && p.title.toLowerCase().includes(query)) ||
                    (p.description && p.description.toLowerCase().includes(query));

                // Товар попадает в результат, если он доступен И подходит по категории И подходит по поиску
                return isAvailable && categoryMatch && searchMatch;
            });

            console.log("Отфильтрованные товары:", filteredProducts);

            // 4. Отрисовываем товары в DOM
            if (productsContainer) {
                productsContainer.innerHTML = ''; // Очищаем контейнер

                if (filteredProducts.length === 0) {
                    productsContainer.innerHTML = '<p class="no-products">Товары не найдены.</p>';
                    return;
                }

                filteredProducts.forEach(p => {
                    const productEl = document.createElement('div');
                    productEl.className = 'product';
                    // --- Адаптируйте HTML под вашу структуру ---
                    productEl.innerHTML = `
                        <img src="${p.images && p.images[0] ? p.images[0].url.trim() : '/path/to/default-image.jpg'}" alt="${p.title || 'Изображение товара'}" />
                        <h3>${p.title || 'Без названия'}</h3>
                        <p class="product-description">${p.description || ''}</p>
                        <div class="product-price">${formatPrice(p.price)}</div>
                        <button class="view-btn" data-product-id="${p.id}">Посмотреть</button>
                        <button class="add-btn" data-product-id="${p.id}">В корзину</button>
                    `;
                    productsContainer.appendChild(productEl);

                    // --- Добавляем обработчики для кнопок внутри карточки товара ---
                    productEl.querySelector('.view-btn')?.addEventListener('click', () => {
                        // Передаем полный объект товара в модальное окно
                        openProductModal(p);
                    });

                    productEl.querySelector('.add-btn')?.addEventListener('click', () => {
                        addToCart(p);
                    });
                });
            }

        } catch (err) {
            console.error('Ошибка при рендеринге товаров:', err);
            if (productsContainer) {
                productsContainer.innerHTML = '<p class="error">Ошибка загрузки товаров. Попробуйте позже.</p>';
            }
        }
    }, 300); // Задержка 300ms перед выполнением (debounce)
}

// --- Модальные окна ---
function openProductModal(product) {
    // --- Адаптируйте под вашу разметку модального окна ---
    const titleEl = document.getElementById('product-title');
    const descEl = document.getElementById('product-description');
    const priceEl = document.getElementById('product-price');
    const mainImgEl = document.getElementById('product-main-image');
    const thumbnailsEl = document.getElementById('thumbnails');

    if (titleEl) titleEl.textContent = product.title || 'Без названия';
    if (descEl) descEl.textContent = product.description || '';
    if (priceEl) priceEl.textContent = formatPrice(product.price);
    if (mainImgEl) {
        mainImgEl.src = product.images && product.images[0] ? product.images[0].url.trim() : '';
        mainImgEl.alt = product.title || '';
    }

    if (thumbnailsEl) {
        thumbnailsEl.innerHTML = '';
        if (product.images && product.images.length > 1) { // Показываем миниатюры, если их больше одной
            product.images.forEach((img, index) => {
                const thumb = document.createElement('img');
                thumb.src = img.url.trim();
                thumb.alt = img.alt || `Изображение ${index + 1} товара ${product.title}`;
                thumb.className = 'thumbnail';
                if (index === 0) thumb.classList.add('active');

                thumb.addEventListener('click', () => {
                    if (mainImgEl) mainImgEl.src = img.url.trim();
                    document.querySelectorAll('.thumbnail').forEach(t => t.classList.remove('active'));
                    thumb.classList.add('active');
                });

                thumbnailsEl.appendChild(thumb);
            });
        }
    }

    window.currentProduct = product; // Сохраняем текущий товар глобально
    if (productModal) productModal.classList.add('open');
}

function openCartModal() {
    // --- Адаптируйте под вашу разметку модального окна корзины ---
    if (cartItems) {
        const cart = getCart();
        cartItems.innerHTML = '';

        if (cart.length === 0) {
            cartItems.innerHTML = '<div class="empty">Ваша корзина пуста</div>';
        } else {
            let total = 0;
            cart.forEach(item => {
                const row = document.createElement('div');
                row.className = 'cart-item';
                row.innerHTML = `
                    <img src="${item.product.images && item.product.images[0] ? item.product.images[0].url.trim() : ''}" alt="${item.product.title || ''}" />
                    <div class="cart-item-info">
                        <div class="cart-item-title">${item.product.title || 'Без названия'}</div>
                        <div class="cart-item-price">${formatPrice(item.product.price)}</div>
                        <div class="cart-quantity">
                            <button class="qty-minus" data-product-id="${item.product.id}">−</button>
                            <span>${item.qty}</span>
                            <button class="qty-plus" data-product-id="${item.product.id}">+</button>
                        </div>
                    </div>
                    <div class="cart-item-total">${formatPrice(item.product.price * item.qty)}</div>
                `;
                cartItems.appendChild(row);
                total += item.product.price * item.qty;
            });

            const totalRow = document.createElement('div');
            totalRow.className = 'total-row';
            totalRow.innerHTML = `<span>Итого:</span><span>${formatPrice(total)}</span>`;
            cartItems.appendChild(totalRow);

            // Обработчики изменения количества
            cartItems.querySelectorAll('.qty-minus').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.productId);
                    if (!isNaN(id)) {
                        updateQuantity(id, -1);
                        openCartModal(); // Перерисовываем модалку
                    }
                });
            });

            cartItems.querySelectorAll('.qty-plus').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const id = parseInt(e.target.dataset.productId);
                    if (!isNaN(id)) {
                        updateQuantity(id, 1);
                        openCartModal(); // Перерисовываем модалку
                    }
                });
            });
        }
    }

    updateSendOrderButton();
    if (cartModal) cartModal.classList.add('open');
}

function closeModals() {
    const openModal = document.querySelector('.modal.open');
    if (openModal) openModal.classList.remove('open');
}

// --- Обновление состояния кнопки отправки заказа ---
function updateSendOrderButton() {
    if (!sendOrderBtn) return;
    if (getCart().length === 0) {
        sendOrderBtn.disabled = true;
        sendOrderBtn.title = 'Нельзя оформить заказ — корзина пуста';
    } else {
        sendOrderBtn.disabled = false;
        sendOrderBtn.title = '';
    }
}

// --- Настройка общих обработчиков событий ---
function setupEventListeners() {

    // --- Обработчик поиска ---
    if (searchInput) {
        // Debounce для поиска тоже
        let searchTimeout;
        searchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                renderProducts(); // Перерисовываем товары при вводе в поиск
            }, 300);
        });
    }

    // --- Обработчики модальных окон и корзины ---
    if (cartBtn) {
        cartBtn.addEventListener('click', openCartModal);
    }

    // Обработчики для кнопок закрытия модалок
    document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', closeModals);
    });

    // --- Обработчики для формы заказа (если есть) ---
    if (phoneInput) {
        phoneInput.addEventListener('input', () => {
            phoneInput.value = phoneInput.value.replace(/[^0-9+]/g, '');
        });
    }

    if (sendOrderBtn) {
        let isSending = false;
        sendOrderBtn.addEventListener('click', async () => {
            if (isSending) return;
            if (!phoneInput || !phoneInput.value.trim()) {
                alert('Укажите телефон');
                return;
            }
            if (getCart().length === 0) {
                alert('Корзина пуста');
                return;
            }

            try {
                isSending = true;
                sendOrderBtn.disabled = true;
                sendOrderBtn.textContent = 'Отправка...';

                const response = await fetch('/api/order', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        phone: phoneInput.value,
                        comment: commentInput ? commentInput.value : '',
                        cart: getCart()
                    })
                });

                const result = await response.json();

                if (result.success) {
                    clearCart();
                    if (phoneInput) phoneInput.value = '';
                    if (commentInput) commentInput.value = '';
                    if (successMessage) successMessage.style.display = 'block';
                    updateCartCount();
                    openCartModal(); // Обновить модалку корзины

                    setTimeout(() => {
                        if (successMessage) successMessage.style.display = 'none';
                        sendOrderBtn.disabled = false;
                        sendOrderBtn.textContent = 'Оформить заказ';
                        isSending = false;
                    }, 3000);
                } else {
                    throw new Error(result.error || 'Ошибка сервера');
                }
            } catch (error) {
                console.error('Ошибка отправки заказа:', error);
                alert('Не удалось отправить заказ. Пожалуйста, позвоните нам.');
                sendOrderBtn.disabled = false;
                sendOrderBtn.textContent = 'Оформить заказ';
                isSending = false;
            }
        });
    }

    console.log("Основные обработчики событий установлены");
}

// --- Экспорт функций в глобальную область видимости ---
window.renderProducts = renderProducts;
window.openProductModal = openProductModal;
window.openCartModal = openCartModal;
window.closeModals = closeModals;
window.setupEventListeners = setupEventListeners;
window.loadCategoriesAndSetupFilters = loadCategoriesAndSetupFilters; // Экспортируем новую функцию
// Также экспортируем вспомогательные, если они используются в других местах
window.getCart = getCart;
window.addToCart = addToCart;
window.updateQuantity = updateQuantity;
window.clearCart = clearCart;
window.updateCartCount = updateCartCount;
window.formatPrice = formatPrice;

console.log("[DEBUG] Функции экспортированы в window");// server.js
require('dotenv').config();
const express = require('express');
const path = require('path');
const fs = require('fs');
const axios = require('axios');

const app = express();
const PORT = process.env.PORT || 3000;

const bcrypt = require('bcryptjs');

app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// === Подключение к БД (только на Render) ===
let pool;
if (process.env.DATABASE_URL) {
  const { Pool } = require('pg');
  pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: {
      rejectUnauthorized: false
    }
  });
}

// Установка часового пояса (если нужно)
process.env.TZ = 'Europe/Moscow';

// === API: Получить товары ===
app.get('/api/products', async (req, res) => {
  try {
    if (pool) {
      // Проверяем, запрашивает ли админ-панель все товары
      const isAdmin = req.query.admin === 'true';
      
      let query = `
        SELECT 
          id, title, description, price, tag, available, category, brand, compatibility,
          images_json as images
        FROM products 
      `;
      
      // Только для обычных пользователей фильтруем по доступности
      // Для админа показываем все товары
      if (!isAdmin) {
        query += 'WHERE available = true ';
      }
      
      query += 'ORDER BY id';
      
      const result = await pool.query(query);
      res.json(result.rows);
    } else {
      console.warn('Подключение к БД не настроено или pool не инициализирован. Возвращается пустой список.');
      res.json([]);
    }
  } catch (err) {
    console.error('Ошибка загрузки товаров:', err);
    res.status(500).json({ error: 'Не удалось загрузить товары' });
  }
});

// === API: Оформить заказ ===
app.post('/api/order', async (req, res) => {
  console.log('=== НАЧАЛО ОБРАБОТКИ ЗАКАЗА ===');
  console.log('Полученные данные:', req.body);

  const { phone, comment, cart } = req.body;

  // 1. Базовые проверки
  if (!phone || !cart || cart.length === 0) {
    console.log('ОШИБКА: Недостаточно данных');
    return res.status(400).json({ success: false, error: 'Недостаточно данных' });
  }

  // 2. Проверка на дублирование запроса
  const requestHash = JSON.stringify({ phone, comment, cart });
  if (req.app.locals.lastOrderRequest === requestHash) {
    console.log('ПРЕДУПРЕЖДЕНИЕ: Повторный запрос с теми же данными обнаружен');
    return res.status(200).json({ 
      success: true, 
      message: 'Заказ уже обрабатывается',
      orderId: req.app.locals.lastOrderId || null
    });
  }
  
  // Сохраняем хэш последнего запроса
  req.app.locals.lastOrderRequest = requestHash;
  
  // Очищаем хэш через 30 секунд
  setTimeout(() => {
    if (req.app.locals.lastOrderRequest === requestHash) {
      req.app.locals.lastOrderRequest = null;
      req.app.locals.lastOrderId = null;
    }
  }, 30000);

  let orderId = null;
  let orderSaved = false;
  let telegramSent = false;

  try {
    // 3. Рассчитываем общую сумму
    const total = cart.reduce((sum, item) => sum + (item.product?.price || 0) * item.qty, 0);
    console.log('Рассчитанная сумма:', total);

    // 4. Получаем московское время для сохранения в БД и Telegram
    const moscowTimeObj = new Date(new Date().toLocaleString("en-US", {timeZone: 'Europe/Moscow'}));
    const moscowTimeString = moscowTimeObj.toLocaleString('ru-RU', {
      timeZone: 'Europe/Moscow',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    console.log('Время заказа (Москва):', moscowTimeString);

    // 5. Вставка основной информации о заказе в БД
    if (pool) {
      console.log('Сохранение заказа в БД...');
      const orderResult = await pool.query(
        'INSERT INTO orders (phone, comment, total_amount, created_at) VALUES ($1, $2, $3, $4) RETURNING id',
        [phone, comment || '', total, moscowTimeObj]
      );
      orderId = orderResult.rows[0].id;
      orderSaved = true;
      req.app.locals.lastOrderId = orderId;
      console.log('Заказ сохранен в БД с ID:', orderId);
    } else {
      console.warn('Подключение к БД отсутствует. Заказ не будет сохранен в БД.');
    }

    // 6. Вставка позиций заказа в БД
    if (pool && orderId) {
      console.log('Сохранение позиций заказа в БД...');
      const itemInserts = cart.map(item => [
        orderId,
        item.product?.id,
        item.product?.title || 'Неизвестный товар',
        item.qty,
        item.product?.price || 0
      ]);

      if (itemInserts.length > 0) {
        const queryText = 'INSERT INTO order_items (order_id, product_id, product_title, quantity, price_per_unit) VALUES ';
        const queryValues = [];
        const placeholders = itemInserts.map((_, index) => {
          const start = index * 5 + 1;
          return `($${start}, $${start+1}, $${start+2}, $${start+3}, $${start+4})`;
        }).join(', ');

        itemInserts.forEach(item => {
          queryValues.push(...item);
        });

        await pool.query(queryText + placeholders, queryValues);
        console.log('Позиции заказа сохранены в БД');
      }
    }

    // 7. Подготавливаем сообщение для Telegram
    const message = `
📦 *Новый заказ на BIZON!*
📞 *Телефон:* \`${phone}\`
💬 *Комментарий:* ${comment || 'не указан'}
🛒 *Товары:*
${cart.map(item => `• ${item.product?.title || 'Неизвестный товар'} ×${item.qty} — ${(item.product?.price || 0) * item.qty} ₽`).join('\n')}
💰 *Итого:* ${total} ₽
🕐 ${moscowTimeString}
`.trim();

    console.log('Подготовленное сообщение для Telegram:', message);

    // 8. Отправка сообщения в Telegram
    const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
    const CHAT_ID = process.env.TELEGRAM_CHAT_ID;

    if (BOT_TOKEN && CHAT_ID) {
      try {
        console.log('Отправка сообщения в Telegram...');
        await axios.post(
          `https://api.telegram.org/bot ${BOT_TOKEN}/sendMessage`,
          {
            chat_id: CHAT_ID,
            text: message,
            parse_mode: 'Markdown',
            disable_web_page_preview: true
          }
        );
        telegramSent = true;
        console.log('Сообщение успешно отправлено в Telegram');
      } catch (telegramError) {
        console.error('Ошибка отправки в Telegram:', telegramError.message);
        // Не прерываем выполнение, если Telegram не работает
      }
    } else {
      console.warn('Токен Telegram бота или ID чата не настроены');
    }

    // 9. Отправка успешного ответа клиенту
    console.log('=== ЗАКАЗ УСПЕШНО ОБРАБОТАН ===');
    res.json({ 
      success: true, 
      orderId: orderId,
      savedToDB: orderSaved,
      sentToTelegram: telegramSent
    });

  } catch (error) {
    console.error('КРИТИЧЕСКАЯ ОШИБКА обработки заказа:', error);
    // Очищаем хэш при ошибке, чтобы можно было повторить попытку
    req.app.locals.lastOrderRequest = null;
    req.app.locals.lastOrderId = null;
    
    // Отправляем клиенту сообщение об ошибке
    res.status(500).json({ success: false, error: 'Ошибка обработки заказа на сервере' });
  }
});

// === API: Получить товар по ID ===
app.get('/api/products/:id', async (req, res) => {
  try {
    const { id } = req.params;
    if (pool) {
      const result = await pool.query(`
        SELECT 
          id, title, description, price, tag, available, category, brand, compatibility,
          images_json as images
        FROM products 
        WHERE id = $1
      `, [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Товар не найден' });
      }
      res.json(result.rows[0]);
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка загрузки товара:', err);
    res.status(500).json({ error: 'Не удалось загрузить товар' });
  }
});

// === API: Создать товар ===
app.post('/api/products', async (req, res) => {
  try {
    const { title, description, price, tag, available, category, brand, compatibility, images } = req.body;
    
    // Преобразуем images обратно в JSON для хранения в БД
    const images_json = images ? JSON.stringify(images) : null;

    if (pool) {
      const result = await pool.query(`
        INSERT INTO products (title, description, price, tag, available, category, brand, compatibility, images_json)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id, title, description, price, tag, available, category, brand, compatibility, images_json as images
      `, [title, description, price, tag, available, category, brand, compatibility, images_json]);

      res.status(201).json(result.rows[0]);
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка создания товара:', err);
    res.status(500).json({ error: 'Не удалось создать товар' });
  }
});

// === API: Обновить товар ===
app.put('/api/products/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { title, description, price, tag, available, category, brand, compatibility, images } = req.body;
    
    // Преобразуем images обратно в JSON для хранения в БД
    const images_json = images ? JSON.stringify(images) : null;

    if (pool) {
      const result = await pool.query(`
        UPDATE products 
        SET title = $1, description = $2, price = $3, tag = $4, available = $5, category = $6, brand = $7, compatibility = $8, images_json = $9
        WHERE id = $10
        RETURNING id, title, description, price, tag, available, category, brand, compatibility, images_json as images
      `, [title, description, price, tag, available, category, brand, compatibility, images_json, id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Товар не найден' });
      }
      res.json(result.rows[0]);
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка обновления товара:', err);
    res.status(500).json({ error: 'Не удалось обновить товар' });
  }
});

// === API: Удалить товар ===
app.delete('/api/products/:id', async (req, res) => {
  try {
    const { id } = req.params;
    if (pool) {
      const result = await pool.query('DELETE FROM products WHERE id = $1 RETURNING id', [id]);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Товар не найден' });
      }
      res.status(204).send(); // 204 No Content - успешно удалено
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка удаления товара:', err);
    res.status(500).json({ error: 'Не удалось удалить товар' });
  }
});

// === API: Получить категории ===
app.get('/api/categories', async (req, res) => {
  try {
    if (pool) {
      // Предполагаем, что у вас есть таблица categories с полями id и name
      const result = await pool.query('SELECT id, name FROM categories ORDER BY name');
      res.json(result.rows);
    } else {
      // Если таблицы нет, возвращаем пустой массив или стандартные категории
      console.warn('Таблица категорий не найдена или pool не инициализирован.');
      res.json([]); // Или res.json([{id: 1, name: 'электроника'}, ...]);
    }
  } catch (err) {
    console.error('Ошибка загрузки категорий:', err);
    res.status(500).json({ error: 'Не удалось загрузить категории' });
  }
});

// === API: Создать категорию ===
app.post('/api/categories', async (req, res) => {
    try {
        const { name } = req.body;
        if (!name) {
            return res.status(400).json({ error: 'Название категории обязательно' });
        }

        if (pool) {
            const result = await pool.query(
                'INSERT INTO categories (name) VALUES ($1) RETURNING id, name',
                [name]
            );
            res.status(201).json(result.rows[0]);
        } else {
            res.status(500).json({ error: 'База данных не настроена' });
        }
    } catch (err) {
        console.error('Ошибка создания категории:', err);
        res.status(500).json({ error: 'Не удалось создать категорию' });
    }
});

// === API: Логин администратора ===
app.post('/api/login', async (req, res) => {
  try {
    const { username, password } = req.body;

    // 1. Базовая валидация
    if (!username || !password) {
      return res.status(400).json({ success: false, message: 'Логин и пароль обязательны' });
    }

    // 2. Проверяем, есть ли подключение к БД
    if (!pool) {
      console.error('Подключение к БД не настроено');
      return res.status(500).json({ success: false, message: 'Ошибка сервера' });
    }

    // 3. Ищем пользователя в БД
    const result = await pool.query(
      'SELECT id, username, password_hash FROM admin_users WHERE username = $1',
      [username]
    );

    // 4. Проверяем, найден ли пользователь
    if (result.rows.length === 0) {
      // В целях безопасности не раскрываем, что пользователь не существует
      return res.status(401).json({ success: false, message: 'Неверный логин или пароль' });
    }

    const user = result.rows[0];

    // 5. Сравниваем хэш пароля
    const isPasswordValid = await bcrypt.compare(password, user.password_hash);
    
    if (!isPasswordValid) {
      return res.status(401).json({ success: false, message: 'Неверный логин или пароль' });
    }

    // 6. Если всё верно, возвращаем успех
    // В реальном приложении здесь бы создавался JWT токен
    res.json({ success: true, message: 'Авторизация успешна' });

  } catch (err) {
    console.error('Ошибка авторизации:', err);
    res.status(500).json({ success: false, message: 'Ошибка сервера при авторизации' });
  }
});

// === API: Удалить категорию ===
app.delete('/api/categories/:id', async (req, res) => {
  try {
    const { id } = req.params;
    if (pool) {
      const result = await pool.query('DELETE FROM categories WHERE id = $1 RETURNING id', [id]);
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Категория не найдена' });
      }
      res.status(204).send(); // 204 No Content - успешно удалено
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка удаления категории:', err);
    res.status(500).json({ error: 'Не удалось удалить категорию' });
  }
});

// === API: Получить заказы ===
app.get('/api/orders', async (req, res) => {
  try {
    if (pool) {
      // Сначала получаем все заказы
      const ordersResult = await pool.query(`
        SELECT 
          id, 
          phone, 
          comment, 
          total_amount, 
          created_at, 
          COALESCE(status, 'новый') as status
        FROM orders 
        ORDER BY created_at DESC
      `);

      // Для каждого заказа получаем его позиции
      const ordersWithItems = await Promise.all(ordersResult.rows.map(async (order) => {
        const itemsResult = await pool.query(`
          SELECT 
            product_id,
            product_title, 
            quantity,
            price_per_unit, 
            (quantity * price_per_unit) as total_price 
          FROM order_items 
          WHERE order_id = $1
          ORDER BY id
        `, [order.id]);

        return {
          ...order,
          items: itemsResult.rows || [] // Передаем позиции с price_per_unit
        };
      }));

      res.json(ordersWithItems);
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка загрузки заказов:', err);
    res.status(500).json({ error: 'Не удалось загрузить заказы: ' + err.message });
  }
});

// === API: Обновить статус заказа ===
app.put('/api/orders/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    // Базовая валидация статуса
    const validStatuses = ['новый', 'в обработке', 'отправлен', 'доставлен', 'отменен'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ error: 'Недопустимый статус' });
    }

    if (pool) {
      const result = await pool.query(
        'UPDATE orders SET status = $1 WHERE id = $2 RETURNING id',
        [status, id]
      );

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Заказ не найден' });
      }

      res.json({ success: true, message: 'Статус обновлен' });
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка обновления статуса заказа:', err);
    res.status(500).json({ error: 'Не удалось обновить статус заказа' });
  }
});

// === API: Удалить заказ ===
app.delete('/api/orders/:id', async (req, res) => {
  try {
    const { id } = req.params;

    if (pool) {
      // Сначала удаляем все позиции заказа
      await pool.query('DELETE FROM order_items WHERE order_id = $1', [id]);
      
      // Потом удаляем сам заказ
      const result = await pool.query('DELETE FROM orders WHERE id = $1 RETURNING id', [id]);

      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Заказ не найден' });
      }

      res.json({ success: true, message: 'Заказ удален успешно' });
    } else {
      res.status(500).json({ error: 'База данных не настроена' });
    }
  } catch (err) {
    console.error('Ошибка удаления заказа:', err);
    res.status(500).json({ error: 'Не удалось удалить заказ: ' + err.message });
  }
});

app.listen(PORT, () => {
  console.log(`✅ Сервер запущен на http://localhost:${PORT}`);
});<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BIZON — Каталог товаров</title>

<link rel="icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">



<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">

  <!-- Preconnect для шрифтов -->
  <link rel="preconnect" href="https://fonts.googleapis.com ">
  <link rel="preconnect" href="https://fonts.gstatic.com " crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Общие стили -->
  <link rel="stylesheet" href="css/base/reset.css">
  <link rel="stylesheet" href="css/layout/header.css">
  <link rel="stylesheet" href="css/components/background.css">
  <link rel="stylesheet" href="css/components/tags.css">
  <link rel="stylesheet" href="css/components/product-card.css">
  <link rel="stylesheet" href="css/components/modal.css">
  <link rel="stylesheet" href="css/components/cart.css">
  <link rel="stylesheet" href="css/layout/footer.css">
</head>
<body>

  <!-- Фоновая анимация -->
  <div class="bg-overlay" aria-hidden="true">
    <div class="pulse-1"></div>
    <div class="pulse-2"></div>
    <div class="pulse-3"></div>
  </div>

  <header class="header" role="banner">
  <div class="logo">
    <div class="logo-icon">
      <img src="assets/logo/logo-Photoroom.png" alt="Логотип BIZON" width="75" height="75">
    </div>
    <div class="logo-title">BIZON</div>
  </div>

  <nav class="main-nav" role="navigation" aria-label="Основная навигация">
    <ul class="nav-list">
      <li><a href="index.html">Главная</a></li>
      <li><a href="catalog.html">Каталог</a></li>
      <li><a href="about.html">О нас</a></li>
      <li><a href="contact.html">Контакты</a></li>
    </ul>
  </nav>

  <div class="header-actions">
    <!-- Поиск — показываем только на catalog.html -->
    <div class="search" id="header-search">
       <svg 
      class="search-icon" 
      aria-hidden="true" 
      focusable="false" 
      viewBox="0 0 24 24" 
      stroke="currentColor" 
      fill="none" 
      stroke-width="2"
    >
      <path 
        stroke-linecap="round" 
        stroke-linejoin="round" 
        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" 
      />
    </svg>
      <input type="text" id="search-input" placeholder="Поиск по товарам..." />
    </div>

    <button id="cart-btn" class="cart-btn" aria-label="Корзина">
      
      Корзина
      <span id="cart-count" class="cart-count">0</span>
    </button>
  </div>
</header>

  <main role="main">
   

   <!-- Фильтры по категориям -->
<!-- Кнопки будут созданы JavaScript'ом, поэтому начальный HTML может быть пустым или содержать заглушку -->
<div class="tags" role="group" aria-label="Фильтры по категориям">
    <!-- Кнопки категорий будут вставлены сюда скриптом -->
    <!-- <button class="tag-btn active" data-category="все">все</button> -->
    <!-- ... остальные кнопки ... -->
</div>

    <!-- Список товаров -->
    <div id="products" class="products" aria-live="polite" aria-atomic="true">
      <!-- Заполняется через JavaScript -->
    </div>
  </main>

  <!-- Модальное окно: Корзина -->
  <div id="cart-modal" class="modal" role="dialog" aria-labelledby="cart-modal-title" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="cart-modal-title" class="modal-title">Корзина</h3>
        <button class="modal-close" data-close="cart" aria-label="Закрыть">&times;</button>
      </div>
      <div class="modal-body" id="cart-items">
        <div class="empty">Ваша корзина пуста</div>
      </div>
      <div class="modal-footer">
        <label for="phone-input" class="visually-hidden">Телефон для связи</label>
        <input type="tel" id="phone-input" placeholder="Телефон для связи" required>

        <label for="comment-input" class="visually-hidden">Комментарий к заказу</label>
        <textarea id="comment-input" placeholder="Комментарий к заказу"></textarea>

        <button id="send-order">Оформить заказ</button>

        <div id="success-message" class="success-message" role="alert" aria-live="assertive">
          ✅ Заказ оформлен! С вами свяжутся в ближайшее время.
        </div>
      </div>
    </div>
  </div>

  <!-- Модальное окно: Товар -->
  <div id="product-modal" class="modal" role="dialog" aria-labelledby="product-title" aria-hidden="true">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Товар</h3>
        <button class="modal-close" data-close="product" aria-label="Закрыть">&times;</button>
      </div>
      <div class="product-modal-body">
        <div class="product-modal-left">
          <div class="product-modal-image">
            <img id="product-main-image" src="" alt="Изображение товара" />
          </div>
          <div class="product-thumbnails" id="thumbnails" role="group" aria-label="Миниатюры изображений"></div>
        </div>
        <div class="product-modal-right">
          <div class="product-info">
            <h3 id="product-title" class="product-title"></h3>
            <p id="product-description" class="product-description"></p>
            <div id="product-price" class="product-price"></div>
          </div>
          <div class="buttons-container">
            <button id="add-to-cart-btn" class="btn-add full-width">Добавить в корзину</button>
            <button id="buy-now-btn" class="btn-buy full-width">Купить сейчас</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Подвал -->
  <footer role="contentinfo">
    © <span id="year"></span> BIZON — Все права защищены
  </footer>

  <!-- Скрипты -->

  <script defer src="js/utils.js"></script>
  <script defer src="js/state.js"></script>
  <script defer src="js/ui.js"></script>
  <script defer src="js/main.js"></script>

  <!-- Инициализация -->
  <script>
    // Установка года
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>
</body>
</html>  что исправить у меня сайт выводит ошибку в консоле [Info] Successfully preconnected to https://fonts.googleapis.com/ 
[Info] Successfully preconnected to https://fonts.gstatic.com/ 
[Error] Failed to load resource: the server responded with a status of 404 (Not Found) (cart.js, line 0)
[Error] Refused to execute http://localhost:3000/js/cart.js as script because "X-Content-Type-Options: nosniff" was given and its Content-Type is not a script MIME type.
[Log] >>> [DEBUG] DOM загружен, инициализация приложения (state.js, line 85)
[Log] >>> [DEBUG] DOM загружен, инициализация приложения (main.js, line 7)
[Error] Unhandled Promise Rejection: ReferenceError: Can't find variable: loadCategoriesAndSetupFilters
	(анонимная функция) (main.js:15)
	(анонимная функция) (main.js:6)
[Error] Ошибка загрузки товаров: – ReferenceError: Can't find variable: formatPrice — ui.js:81
ReferenceError: Can't find variable: formatPrice — ui.js:81
	(анонимная функция) (ui.js:116) надо чтобы была фильтрация по категориям товара